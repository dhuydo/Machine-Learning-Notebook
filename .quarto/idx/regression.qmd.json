{"title":"Regression","markdown":{"headingText":"Regression","headingAttr":{"id":"sec-regression","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n## Linear Regression\n\nSuppose that we have a data set of demographic and healthcare cost for each individual in a city, and we want to predict the total healthcare cost based on age.\n\nIf we use linear regression method for this task, we will assump that the relationship between these features is *linear* and try to fit a `line` so that is closest to the data. The plot looks like this.\n\n```{python}\n#| code-fold: true\n\n## Simple linear regression plot\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(29)\nm = 100      # number of instances\nx = np.random.randint(18,80,m)\ny = np.random.randint(-200,200,m) + 20*x\n\nplt.plot(x,y,'b.', label='True values')\nplt.plot(x, 20*x,'-',color='r', label='Linear regression')\nplt.xlabel('Age')\nplt.ylabel('Healthcare cost')\nplt.legend()\n\nplt.show()\n```\n\nIf you have another feature using to predict (e.g. weight), the plot will look like this. For â‰¥3 features, it's called 'Multiple linear regression' and we will fit a `hyperplane` instead.\n\n```{python}\n#| code-fold: true\n\n## Multiple linear regression plot\n\nfrom sklearn.linear_model import LinearRegression\nimport pandas as pd\nfrom mpl_toolkits.mplot3d import Axes3D\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nz = np.random.randint(20,30,m)\ny = np.random.randint(-200,200,m) + 20*x +30*z\n\nX_train = np.c_[x,z]\nlm = LinearRegression()\nlm.fit(X_train, y)\n\n\n# Setting up the 3D plot\nfig = plt.figure(figsize=(10, 7))\nax = fig.add_subplot(111, projection='3d')\n\n# Scatter plot of actual data\nax.scatter(x, z, y, color='blue', marker='o', alpha=0.5, label='True values')\n\n# Creating a meshgrid for the plane\nx_surf = np.linspace(x.min(), x.max(), 100)\nz_surf = np.linspace(z.min(), z.max(), 100)\nx_surf, z_surf = np.meshgrid(x_surf, z_surf)\n\n# Predicting the values from the meshed grid\nvals = pd.DataFrame({'Age': x_surf.ravel(), 'Weight': z_surf.ravel()})\ny_pred = lm.predict(vals)\nax.plot_surface(x_surf, z_surf, y_pred.reshape(x_surf.shape), color='r', alpha=0.3, label='Hyperplane')\n\n# Labeling the axes\nax.set_xlabel('Age')\nax.set_ylabel('Weight')\nax.set_zlabel('Healthcare cost')\n#ax.legend()\n\nplt.show()\n\n```\n\nThe formula of the line (n=1)/hyperplane (n>1) is:\n$$\n\\hat{y} = Î¸_o +Î¸_1x_1 +Î¸_2x_2+...+Î¸_nx_n\n$$\n\n- Å·: predicted value\n- n: number of features\n- x_i: the i_th feature value\n- Î¸_i: the i_th parameter value (Î¸_0: intercept; Î¸_1 - Î¸_n: weight of parameters)\n\nFor linear algebra, this can be written much more concisely using a vectorized form like this:\n$$\\hat{y} = Î¸.X$$\n\n- Î¸: vecto of weights (of parameters)\n- X: matrix of features\n\nSo how can we find the best fitted line, the left or the right one?\n\n```{python}\n#| code-fold: true\n\nnp.random.seed(29)\nm = 100      # number of instances\nx = np.random.randint(18,80,m)\ny = np.random.randint(-200,200,m) + 20*x\n\nplt.subplot(1,2,1)\nplt.plot(x,y,'b.', label='True values')\nplt.plot(x, 20*x,'-',color='r')\nplt.xlabel('Age')\nplt.ylabel('Healthcare cost')\n\nplt.subplot(1,2,2)\nplt.plot(x,y,'b.', label='True values')\nplt.plot(x, 10+18*(x+10),'-',color='r')\nplt.xlabel('Age')\n\nplt.show()\n```\n\nIt turns out that we have 2 common strategy:\\\n- Linear algebra: using `normal equation`\\\n- Optimization: using `gradient descent`\n\n### Normal Equation {#sec-normal-equation}\n\n$$Î¸ = (X^{T}X)^{-1}X^{T}y$$\n\n- Î¸: vecto of weights (of parameters)\n- X: matrix of features\n- y: vecto of target value\n\nThat's all we need to compute the best weights (coefficients). \n\nBut in reality, not all cases matrix is invertible, so `LinearRegression` in `sklearn` compute *pseudoinverse (X+)* instead, using a standard matrix factorization technique called singular value decomposition (SVD) that decompose X into (UÎ£V^T):\n$$\n\\begin{gather}\nÎ¸ = X^{+}Y\\\\\n   X = UÎ£V^{T}\\\\\nX^{+} = VÎ£^{+}U^{T}\n\\end{gather}\n$$\n\nImplement Linear regression using sklearn\n\n```{python}\nfrom sklearn.linear_model import LinearRegression\n\nnp.random.seed(29)\nx = np.random.randint(18,80,m)\ny = np.random.randint(-200,200,m) + 20*x\nX_train = x.reshape(-1,1)\n\nlinear = LinearRegression()\nlinear.fit(X_train,y)\ny_pred = linear.predict(X_train)\nprint(f'Equation: {linear.intercept_:.2f} + {linear.coef_[0]:.2f}*x')\n\nplt.plot(x, y, 'b.', label='True values')\nplt.plot(x, y_pred,'-',color='r', label='Linear regression')\nplt.xlabel('Age')\nplt.ylabel('Healthcare cost')\nplt.legend()\n\nplt.show()\n```\n\nBoth the Normal equation and SVD approach scale well with the number of instances, but scale very badly with number of features. Therefore, we will look at another approach which is better suited for cases where there are a large number of features or too many training instances to fit in memory.\n\n\n### Gradient Descent\n\n#### How does GD work?\n\nIn fact, the computer really like the term 'optimization', which means we will take the result roughly equal to the correct one with the acceptable error. Gradient descent (GD) is that kind of method.\n\nGenerally, GD tweaks the weights iteratively in order to minimize a `cost function`. Steps to do Gradient Descent:\n\n1. Take `Gradient (derivative)` of Loss Function\n2. Random initialization (take random weights)\\\nLoop step 3-5 until **converge**:\\\n3. Compute gradient\n4. Compute `step size`: StepSize = Gradient * Learning_rate\n5. Compute new weights: New = Old - StepSize\n\n- [i] Run single epoch:\n\t- partial_fit(): ignore (*max_iter*, *tol*) do not reset epoch counter\n\t- fit(warm_start = True)\n\n::: {.callout-note}\n- Loss function: also called `cost function`, is the amount that we have to pay if we use the specific set of weights. Of course we want to minimize it cause everyone want to pay less but gain more, right ðŸ˜†\n\n- Learning rate: the pace of changing the weights in respond to the estimated loss\\\n    - Too small: take a long time to converge\n    - Too high: diverge\n\n- Number of epochs: times that we update our weights\n    - Too low: can't get optimal solution\n    - Too high: waste time (parameters do not change much)\n    - `Solution`: set large *epoch* and a *tolerance* to interrupt when *grandient* < *tolerance*\n:::\n\n::: {#fig-learning-rates layout-ncol=3} \n\n![Suitable learning rate](images/learning-rate.png)\n\n![Too low learning rate](images/high-lr.png) \n\n![Too high learning rate](images/low-lr.png)\n\nLearning rate strategy\n:::\n\n\n#### GD pitfalls\n\n- *Local minimum*: If we initialize weights from the left, we will reach local minimum instead of global minimum\n- *Plateau*: if we initialize weights from the right, the gradient will change slowly and adding new instances to the training set doesnâ€™t make the average error much better or worse. If early stopping, we will never reach the global minimum\n\n![Gradient descent pitfalls](images/gd-pitfalls.png){#fig-gd-pitfalls}\n\nFortunately, the cost function of linear regression is a *convex function*, which means it has no local minimum/ just one global minimum, and its slope never changes abruptly\n\n$$\nMSE = \\frac{1}{2m}\\sum_{i=1}^{m}{(Î¸^{T}x_{i}-y_{i})}^2\n$$\n\n- Another pitfall of GD: features have very different scales. Therefore, when using gradient descent, you should ensure that all features have a similar scale (e.g., using Scikit-Learnâ€™s *StandardScaler* class), or else it will take much longer to converge.\n\n![Gradient descent with (left) and without (right) feature scaling](images/gd-scales.png){#fig-gd-scales.png}\n\n#### Implement gradient descent using sklearn\n\n```{python}\nfrom sklearn.linear_model import SGDRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import make_pipeline\n\nsgd = make_pipeline(StandardScaler(),\nSGDRegressor(max_iter=1000, tol=1e-3))\nsgd.fit(X_train, y)\nprint('Equation: %.2f + %.2f*x' % (sgd['sgdregressor'].intercept_[0], sgd['sgdregressor'].coef_[0]))\n\ny_pred = sgd.predict(X_train)\n\nplt.plot(x, y, 'b.', label='True values')\nplt.plot(x, y_pred,'-',color='r', label='Stochastic gradient descent regressor')\nplt.xlabel('Age')\nplt.ylabel('Healthcare cost')\nplt.legend()\n\nplt.show()\n```\n\n::: {.callout-warning}\nThe intercept and coefficient in this equation are different from @sec-normal-equation because they implement on scaled X_train\n:::\nLearn more about [Gradient descent](gradient-descent.qmd).\n\n\n## Polynomial Regression\n\nIf the data is more complex (non linear), what do we do? In that case, we just create new features by adding powers to existed features, and use them to fit to our linear model. This technique is called *polynomial regression*.\n\nFor example, we will use sklearn's `PolynomialFeatures` to transform our data to higher degree, and then fit it to `LinearRegression`.\n\n```{python}\n#| code-fold: true\nnp.random.seed(29)\nm = 100\nX = 10*np.random.rand(m, 1)-5\ny = 10+ 1.5*X**2 + X + np.random.randn(m,1)\n\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.pipeline import make_pipeline\n\npipe = make_pipeline(PolynomialFeatures(degree=2, include_bias=False), LinearRegression())\n\npipe.fit(X, y)\ny_pred = pipe.predict(X)\n\nX_new = np.linspace(-5, 5, 100).reshape(-1, 1)\ny_pred_new = pipe.predict(X_new)\n\nplt.plot(X, y, 'b.', label='True values')\nplt.plot(X_new, y_pred_new,'-',color='r', label='Stochastic gradient descent regressor')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\n\nplt.show()\n```\n\n::: {.callout-tip}\nIf we have n features, d degree: `PolynomialFeatures` transform into `(n+d)! / (n!d!)` features\n:::\n\n\n\n## Learning Curve\n\n> How complex polynomial should be?\n\n- Underfitting (1 dgree): too simple model, can't capture the pattern of data\n- Overfitting (300 degrees): too complex model, tend to remember data\n\n![Different polynomial degree](images/different-degrees.png){#fig-different-degrees}\n\n> How can tell overfitting or underfitting? There are 2 strategies\n\n**Cross-validation**\\\n- Overfitting: model perform well on train set, generate poorly on validation set\\\n- Underfitting: perform poorly on both train and validation sets\n\n**Learning Curve**\n- Plot `training errors` and `validation errors` over training set sizes (using cross-validation)\\\n    - Overfitting: *gap* between the curves\n    - Underfitting: *Plateau* (adding more training samples do not help)\n\n> So how do we handle the overfitting/underfitting model?\n\n- Overfitting: Change too simpler model, feeding more training data, constrain the weights of unimportant features\\\n- Underfitting: Change to more complex algorithm; better features\n\n::: {.callout-important}\n## Bias-Variation Trade-Off\n\n1. **Bias (underfitting)**: wrong assumptions (e.g. assump linear while quadratic)\n2. **Variation (overfitting)**: remember data (sensitive to variations in data)\\\n=> `Trade-Off`: Increase model's complexity will increase variation and decrease bias\\\n3. **Irreducible error**: noisiness => clean up data\n:::\n\n\n\n## Regularized Linear Models\n\nAs mentioned above, to reduce overfitting we constrain the weights of model. These techniques are called `regularization` including: Ridge regression, Lasso Regression and Elastic net.\n\n::: {.callout-tip}\n- Regularized linear models: Sensitive to the scale \\\n=> *StandardScaler* before regularize\\\n\n- In almost cases, we should avoid plain Linear regression\n\n- Use case of Regularized linear models:\n1. Elastic Net: when there are few useful features, (features > instances, correlated features => Lasso tends to behave erratically)\n2. Lasso: when there are few useful features\n3. Ridge: good for default (a *warmstart*)\n\n- Find out more about *RidgeCV*, *LassoCV* and *ElasticNetCV*\n:::\n\n@fig-l1-l2\n\n### Ridge Regression\nAdd a *regularization term (L2 norm)* to the MSE cost function of Linear regression in order to keep the weights as small as possible\n\nRidge regression cost function\n$$\n\\begin{equation}\n\\begin{split}\nJ(Î¸) & = MSE(Î¸) + \\frac{Î±}{2m}\\sum_{i=1}^{m}w_i^2\\\\\n    & = MSE(Î¸) + \\frac{Î±}{2m}Î¸^Î¤Î¸\n\\end{split}\n\\end{equation}\n$$\n\nClosed-form equation\n$$Î¸ = (X^{T}X + Î±Î‘)^{-1}X^{T}Y$$\n\n::: {.callout-tip}\nsklearn.linear_model.Ridge(solver='cholesky')\n:::\n\n```{python}\nfrom sklearn.linear_model import Ridge\n\nnp.random.seed(29)\nm = 50\nX = 3 * np.random.rand(m, 1)\ny = 1 + 0.5 * X + np.random.randn(m, 1) / 1.5\n\ndef make_plot(alphas):\n    plt.plot(X, y, 'b.')\n    for alpha, style in zip(alphas, ['b:','r--','g-']):\n        pipe = make_pipeline(PolynomialFeatures(degree=5, include_bias=False), Ridge(alpha=alpha, solver='cholesky'))\n        pipe.fit(X, y)\n        X_new = np.linspace(0, 3, 100).reshape(-1, 1)\n        y_pred_new = pipe.predict(X_new)\n\n        plt.plot(X_new, y_pred_new, style, label='alpha = %s' % alpha)\n    plt.axis([0, 3, 0, 3.5])\n    plt.legend()\n    plt.show()\n\nmake_plot([0,0.1,1])\n```\n\nGradient descent\n$$\n\\begin{gather}\nâˆ‡ = \\frac{1}{m}X^{T}(XÎ¸ - y)+\\frac{Î±}{m}Î¸\\\\\n\\\\\nÎ¸ = Î¸ - Î»âˆ‡\\\\\n\\end{gather}\n$$\n\nThese 2 models are equally, in which we have to set the lpha in the SGD to be alpha/m\n\n```{python}\nfrom sklearn.linear_model import Ridge\n\nalpha = 0.01\n\nridge = Ridge(alpha=0.1, random_state=29)\nsgd = SGDRegressor(penalty='l2', alpha=0.1/m, random_state=29)\n```\n\n\n\n### Lasso Regression\n\nAdd a *regularization term (L1 norm)* to the MSE cost function of Linear regression, but tend to `eliminate` weights of least important features\\\n=> Weights is `sparse matrix`\n\nLasso regression cost function\n$$\n\\begin{equation}\n\\begin{split}\nJ(Î¸) & = MSE(Î¸) + Î±\\sum_{i=1}^{m}|w|\\\\\n    & = MSE(Î¸) + Î±Î¸\n\\end{split}\n\\end{equation}\n$$\n\nGradient descent\n\nThe L1 regularization is not differentiable at Î¸i = 0, but gradient descent still works if we use a *subgradient vector* g11 instead when any Î¸i = 0. Learn more about [gradient descent for lasso regression](https://www.cs.cmu.edu/afs/cs/project/link-3/lafferty/www/ml-stat2/talks/YondaiKimGLasso-SLIDE-YD.pdf)\n\nThese 2 models are equally, and we have to adjust the alpha as same as ridge regression\n\n```{python}\nfrom sklearn.linear_model import Lasso\n\nalpha = 0.01\n\nridge = Lasso(alpha=0.1, random_state=29)\nsgd = SGDRegressor(penalty='l1', alpha=0.1/m, random_state=29)\n```\n\n\n### Elastic Net Regression\n\nElastic Net is weighted sum of Ridge and Lasso regression, change the weights by *r* rate: 0 (more Ridge) to 1 (more Lasso)\n\n$$\nJ(Î¸) = MSE(Î¸) + r*\\frac{Î±}{2m}\\sum_{i=1}^{m}w_i^2 + (1-r)Î±\\sum_{i=1}^{m}|w_i|\n$$\n\n```{python}\nfrom sklearn.linear_model import ElasticNet\n\nelast = ElasticNet(alpha=0.01, l1_ratio=0.5)\n```\n\n\n## Early Stopping\n\nAnother way to regularize iterative learning algorithms (e.g. GD): *partial_fit* for n epochs and save the model has the lowest validation error\n\n```{python}\nfrom copy import deepcopy\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error\n\n\n## Create data\n\nnp.random.seed(29)\nm = 100\nX = 6 * np.random.rand(m, 1) - 3\ny = 0.5 * X ** 2 + X + 2 + np.random.randn(m, 1)\nepochs = 500\nbest_rmse = np.inf\n\nx_train, x_test, y_train, y_test = train_test_split(X, y)\n\npreprocessing = make_pipeline(PolynomialFeatures(degree=90, include_bias=False), StandardScaler())\nX_train = preprocessing.fit_transform(x_train)\nX_test = preprocessing.transform(x_test)\n\n\nsgd = SGDRegressor(penalty='elasticnet', alpha=0.01, l1_ratio=0.5, eta0=0.001, random_state=29)\n\nfor epoch in range(epochs):\n    sgd.partial_fit(X_train, y_train.ravel())\n    y_pred = sgd.predict(X_test)\n    rmse = mean_squared_error(y_test, y_pred, squared=False)\n    if rmse < best_rmse:\n        best_rmse = rmse\n        best_model = deepcopy(sgd)\n\ny_pred = best_model.predict(X_test)\n\n\n## Another way to apply early stopping\n\n# sgd = SGDRegressor(penalty='elasticnet', alpha=0.01, l1_ratio=0.5, max_iter = 2000, tol=0.00001, shuffle=True, random_state=29, learning_rate='invscaling', eta0=0.001, early_stopping=True, validation_fraction=0.25, n_iter_no_change=10)\n# sgd.fit(X_train, y_train.ravel())\n# y_pred = sgd.predict(X_test)\nprint('RMSE: %.2f' % mean_squared_error(y_test, y_pred))\n```\n\n::: {.callout-tip}\n*partial_fit*: *max_iter=1* (fit 1 epoch per calling); learn `incrementally` from a mini-batch of instances => useful when data is not fit into memory\n\n*fit*: train model from scratch (all instances at once)\n\n*fit(warm_start=True)* = partial_fit: allow learning from the weights of previous fit\n\ncopy.deepcopy(): copies both the modelâ€™s *hyperparameters* and the *learned parameters*\n\nsklearn.base.clone() only copies the modelâ€™s *hyperparameters*.\n:::\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"regression.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["references.bib"],"editor":"visual","jupyter":"dhuy","theme":{"light":"cosmo","dark":"darkly"},"author-meta":"Nguyen Cao Duc Huy","callout-appearance":"simple"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"regression.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"editor":"visual","jupyter":"dhuy","documentclass":"scrreport"},"extensions":{"book":{"selfContainedOutput":true}}},"epub":{"identifier":{"display-name":"ePub","target-format":"epub","base-format":"epub"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"epub","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":false,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"default-image-extension":"png","html-math-method":"mathml","to":"epub","output-file":"regression.epub"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"bibliography":["references.bib"],"editor":"visual","jupyter":"dhuy","cover-image":"cover.png"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf","epub"]}